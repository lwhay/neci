package org.apache.trevni.avro.update;

import static org.apache.trevni.avro.update.AvroColumnator.isSimple;

import java.io.File;
import java.io.IOException;
import java.util.Collection;
import java.util.List;

import org.apache.avro.Schema;
import org.apache.avro.Schema.Field;
import org.apache.avro.Schema.Type;
import org.apache.avro.generic.GenericData;
import org.apache.avro.generic.GenericData.Record;
import org.apache.avro.generic.GenericFixed;
import org.apache.avro.util.Utf8;
import org.apache.trevni.update.FileColumnMetaData;
import org.apache.trevni.update.FileMetaData;
import org.apache.trevni.update.InsertColumnFileWriter;
import org.apache.trevni.update.InsertColumnFileWriter.ListArr;
import org.apache.trevni.TrevniRuntimeException;

public class InsertAvroColumnWriter {
  private Schema schema;
  private InsertColumnFileWriter writer;
  private FileColumnMetaData[] meta;
  private FileMetaData filemeta;
  private MyMap<Long, Record> sort;
  //private Object[][] insertsort;
  //private List<Object>[] insertsort;
  private ListArr[] v;
  //private int[] keyfields;
  private File file0, file1;
  private int[] arrayWidths;
  private GenericData model;
  boolean changefile = false;
  int x = 0;
  long start, end;

  public static final String SCHEMA_KEY = "avro.schema";
  private static final int MAX = 200000;

  public InsertAvroColumnWriter(Schema schema, String file0, String file1) throws IOException {
    this.schema = schema;
    AvroColumnator columnator = new AvroColumnator(schema);
    filemeta = new FileMetaData();
    filemeta.set(SCHEMA_KEY, schema.toString());
    this.meta = columnator.getColumns();
    this.writer = new InsertColumnFileWriter(filemeta, meta);
    this.arrayWidths = columnator.getArrayWidths();
    this.model = GenericData.get();
    //this.keyfields = keyfields;
    this.file0 = new File(file0);
    this.file1 = new File(file1);
    sort = new MyMap();
    start = System.currentTimeMillis();
  }

  public class SortedKey implements Comparable<SortedKey> {
    private Type[] type;
    private Object[] value;

    public SortedKey(int[] keyfields, Record record) {
      type = new Type[keyfields.length];
      value = new Object[keyfields.length];
      List<Field> fields = record.getSchema().getFields();
      for (int i = 0; i < keyfields.length; i++) {
        type[i] = fields.get(keyfields[i]).schema().getType();
        if (!isSimple(type[i]))
          value[i] = record.get(keyfields[i]);
      }
    }

    boolean isSimple(Type s) {
      switch (s) {
        case INT:
        case LONG:
        case FLOAT:
        case DOUBLE:
        case BYTES:
        case STRING:
          return true;
        default:
          return false;
      }
    }

    @Override
    public int compareTo(SortedKey other) {
      return 1;
    }
  }

  //public static void MemPrint(){
  //System.out.println("*********\t"+(Runtime.getRuntime().totalMemory() - Runtime.getRuntime().freeMemory()));
  //}

  public void append(Record value) throws IOException {
    sort.put(Long.parseLong(value.get(0).toString()), value);
    //MemPrint();
    if (sort.size() == MAX) {
      //            for (Record record : sort.values()) {
      //                Object[] v = new Object[meta.length];
      //                int count = append(record, schema, 0, v);
      //                assert (count == v.length);
      //                insertsort.put((Long) v[0], v);
      //                columnWriter.write(record);
      //            }
      //sort.clear();
      //       MemPrint();
      if (changefile) {
        appendTo(file0, file1);
        changefile = !changefile;
      } else {
        appendTo(file1, file0);
        changefile = !changefile;
      }
      end = System.currentTimeMillis();
      x++;
      //MemPrint();
      System.out.println("############" + x+"\ttime: "+(end - start)+"ms");
      start = System.currentTimeMillis();
    }
  }

  public void flush() throws IOException {
    if (!sort.isEmpty()) {
      x++;
      if (changefile) {
        appendTo(file0, file1);
        changefile = !changefile;
      } else {
        appendTo(file1, file0);
        changefile = !changefile;
      }
      System.out.println("############" + x);
    }
  }

  private int append(Object o, Schema s, int column) throws IOException {
    if (isSimple(s)) {
      appendValue(o, s, column);
      return column + 1;
    }
    switch (s.getType()) {
      case RECORD:
        for (Field f : s.getFields())
           column = append(model.getField(o, f.name(), f.pos()), f.schema(), column);
           return column;
      case ARRAY:
        Collection elements = (Collection) o;
        appendValue(elements.size(), s, column);
        if (isSimple(s.getElementType())) { // optimize simple arrays
          column++;
          for (Object element : elements)
            appendValue(element, s.getElementType(), column);
          return column + 1;
        }
        for (Object element : elements) {
          int c = append(element, s.getElementType(), column + 1);
          assert (c == column + arrayWidths[column]);
        }
        return column + arrayWidths[column];
      default:
        throw new TrevniRuntimeException("Unknown schema: " + s);
    }
  }

  private void appendValue(Object o, Schema s, int column) throws IOException {
    switch(s.getType()){
      case STRING:
        if(o instanceof Utf8)
          o = o.toString();
        break;
      case ENUM:
        if(o instanceof Enum)
          o = ((Enum)o).ordinal();
        else
          o = s.getEnumOrdinal(o.toString());
        break;
      case FIXED:
        o = ((GenericFixed) o).bytes();
        break;
    }
    v[column].add(o);
  }

  public void appendTo(File fromfile, File tofile) throws IOException {
    //insertsort = new Object[meta.length][];
    tofile.delete();
    v = new ListArr[meta.length];
    for (int k = 0; k < v.length; k++) {
      v[k] = new ListArr();
    }
    List<Record> values = sort.values();
    //MemPrint();
    sort.clear();
    //MemPrint();
    for (int i = values.size(); i > 0; i--) {
      Record record = values.get(i - 1);
      //v.clear();
      int count = append(record, schema, 0);
      assert (count == meta.length);
    }
    //MemPrint();
    values = null;
    //MemPrint();
    //for (int k = 0; k < meta.length; k++) {
      //insertsort[k] = v[k].x.toArray();
      //v[k].clear();
    //}
    writer.setInsert(v);
    //MemPrint();
    v = null;
    //MemPrint();
    if (!fromfile.exists()) {
      //InsertColumnFileWriter writer = new InsertColumnFileWriter(filemeta, meta, insertsort);
      writer.appendTo(tofile);
      //AvroColumnWriter<Record> columnWriter = new AvroColumnWriter<Record>(schema, new ColumnFileMetaData());
      //for (Record record : sort.values()) {
        //columnWriter.write(record);
      //}
      //sort.clear();
      //columnWriter.writeTo(tofile);
    } else {
      writer.setReadFile(fromfile);
      //InsertColumnFileWriter writer = new InsertColumnFileWriter(fromfile, insertsort);
      writer.insertTo(tofile);
    }
  }
}
